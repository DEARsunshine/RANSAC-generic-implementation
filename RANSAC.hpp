#ifndef RANSAC_HPP
#define RANSAC_HPP

#include <ctime>
#include <random>
#include <set>
#include <cmath>
#include <iostream>
#include <assert.h>
#include "DataType.hpp"

using std::set;
using std::cout;
using std::endl;

namespace ransac {

/*
A common pseudo-code version of RANSAC algorithm is showed below.

Given:
    data - a set of observed data points
    model - a model that can be fitted to data points
    n - the minimum number of data values required to fit the model
    k - the maximum number of iterations allowed in the algorithm
    t - a threshold value for determining when a data point fits a model
    d - the number of close data values required to assert that a model fits well to data
Return:
    bestfit - model parameters which best fit the data (or nil if no good model is found)

iterations = 0
bestfit = nil
besterr = something really large
while (iterations < k) {
    maybeinliers = n randomly selected values from data
    maybemodel = model parameters fitted to maybeinliers
    alsoinliers = empty set
    for every point in data not in maybeinliers {
        if point fits maybemodel with an error smaller than t
             add point to alsoinliers
    }
    if the number of elements in alsoinliers is > d {
        % this implies that we may have found a good model
        % now test how good it is
        bettermodel = model parameters fitted to all points in maybeinliers and alsoinliers
        thiserr = a measure of how well model fits these points
        if thiserr < besterr {
            bestfit = bettermodel
            besterr = thiserr
        }
    }
    increment iterations
}
return bestfit


Here the iteration time k can be calculated by three variables:
  1.successProbability -- the desired probablity of successfully fitting a robust model from the dataset.
  2.probabilityForInlier -- the approximate percentage of "inliers" among all data.
  3.minEstimateNum -- the minimum number of data values required to fit the model
With some deduction, we can conclude following formula:
  iterateTimes = log2(1 - successProbability) / log2(1 - pow(probabilityForInlier, minEstimateNum));

*/

/*
	@para DataType is the type/class of data used for fitting, such as a set of 2D points.
	@para Model is the model used to fit the data, it can be a class/struct of 2D/3D line/circle, matrix, etc.
*/
template<typename DataType, typename Model>
class RANSAC {
private:
	// The set of observed data points which are used for fitting the desired model.
	vector<DataType> data;
	/*
	  model is the pointer to the desired model.
	  It is generated by fitting to data points with RANSAC.
	  The model must contain two
	*/
	Model* model;
	/*
	 The minimum number of data values required to fit the model.
	 (2 for a line and 3 for a circle.)
	*/
	int minEstimateNum;
	// The maximum number of iterations allowed in the algorithm.
	int	iterateTimes;
	/*
	 The threshold value for determining whether a data point fits a model 
	 (By comparing the distance from the model with the threshold).
	*/
	double threshold;
	/*
	 The number of close data values required to assert that a model fits well to data.
	 Namely if a model is 'good', the minimum number of points
	  that can be fitted with the model is (fitWellNum + minEstimateNum) 
	*/
	int	fitWellNum;
	//FitModelFromData fitModelFromData;
	/*Model (*fitModelFromData)(vector<DataType> &a, bool &b);*/
	/*
	 Probability for drawing an outlier free subset
	   or the probablity to successfully get a "good" model.
	 */
	double successProbability;
	// probabilityForInlier is the ratio: number of inliers in data / number of points in data.
	double probabilityForInlier;
	//Threshold fitError(maybeModel, data[index]);
public:
	/*RANSAC(vector<DataType> &_data, Model &_model, Threshold _threshold, int _minEstimateNum, double _desiredProbability,
		double _probabilityForInlier, FitModelFromData &_fitModelFromData) :
		data(_data), model(_model), threshold(_threshold), minEstimateNum(_minEstimateNum), desiredProbability(_desiredProbability),
		probabilityForInlier(_probabilityForInlier), fitModelFromData(_fitModelFromData)
		{ }*/
	//void compute();
	/*void setModel(Model* _model) {
		model = _model;
	}*/
	RANSAC() {
		data.clear();
		model = NULL;
		minEstimateNum = iterateTimes = fitWellNum = successProbability = probabilityForInlier = 0;
	}
	~RANSAC() {
		data.clear();
		delete model;
		//model = NULL;
	}
	void initPara() {

	}
	void setData(vector<DataType> &_data) {
		assert(!_data.empty());
		data = _data;
	}
	void setThreshold(double _threshold) {
		assert(_threshold > 0);
		threshold = _threshold;
	}
	void setMinEstimateNum(int _minEstimateNum) {
		assert(_minEstimateNum > 0);
		minEstimateNum = _minEstimateNum;
	}
	void setSuccessProbability(double _successProbability) {
		assert(0 < _successProbability && _successProbability < 1);
		successProbability = _successProbability;
	}
	void setProbabilityForInlier(double _probabilityForInlier) {
		assert(0 < _probabilityForInlier && _probabilityForInlier < 1);
		/*if (_probabilityForInlier <= 0 || _probabilityForInlier > 1) {
			cout << "Invalid probability for inlier!" << endl;
		}*/
		probabilityForInlier = _probabilityForInlier;
	}
	void setFitWellNum(int _fitWellNum) {
		assert(_fitWellNum > 0);
		fitWellNum = _fitWellNum;
	}
	void setIterateTimes(int _iterateTimes) {
		assert(_iterateTimes > 0);
		iterateTimes = _iterateTimes;
	}
	void calculateIterationTimes() {
		/*
		  The initial value of iterateTimes is 0.
		  So if it is not set, we should use the formula below to calculate the iteration time.
		*/
		if (iterateTimes == 0) {
			iterateTimes = std::log2(1 - successProbability) / std::log2(1 - pow(probabilityForInlier, minEstimateNum));
		}
	}

	/*
		findbestFit is the implementation of RANSAC.
		@return A pointer to the model we find in the process of RANSAC.
	*/
	Model* findBestFit() {
		assert(minEstimateNum <= data.size());
		/*if (minEstimateNum > data.size()) {
			
			cout << "Not enough points given!" << endl;
		}*/
		// bestFit stores pointer of the final result (the best fit model).
		Model* bestFit = NULL;
		// Initial value of bestError is a large value.
		double bestError = 9999999.0f;
		//Model maybeModel;
		//vector<DataType> maybeInliers; 
		//double w;  // w = number of inliers in data / number of points in data
		calculateIterationTimes();
		// @test
		cout << "iterateTimes = " << iterateTimes << endl;
		int iteration = 0;
		srand(time(NULL));
		while (iteration < iterateTimes) {

			/*
			  Randomly select data minEstimateNum times from dataset.
			  Store their indices in the dataset so that we can access them directly.
			*/
			set<int> maybeInlierIndices;
			int dataSize = data.size();
			while (maybeInlierIndices.size() < minEstimateNum) {
				int index = std::rand() % dataSize;
				//cout << "index = " << index << endl;
				maybeInlierIndices.insert(index);
			}
			
			/*
			
			*/
			vector<DataType> maybeInliers;
			set<int>::iterator it = maybeInlierIndices.begin();
			for (; it != maybeInlierIndices.end(); it++) {
				maybeInliers.push_back(data[*it]);
			}

			//bool modelExists = true;
			Model* maybeModel = new Model(maybeInliers, "directlyFitModel");

			/*if (!modelExists) {
				cout << "Not enough points to fit the model" << endl;
				return model;
			}*/

			vector<DataType> alsoInliers;
			for (int index = 0; index < data.size(); index++) {
				if (maybeInlierIndices.find(index) == maybeInlierIndices.end()) { // 不在maybeinliers
					if (maybeModel->disFromModel(data[index]) < threshold) {
						alsoInliers.push_back(data[index]);
					}
				}
			}
			//cout << "alsoInliers :" <<alsoInliers.size() << endl;

			vector<DataType> &consensusSet = maybeInliers;
			if (alsoInliers.size() > fitWellNum) {
				for (int i = 0; i < alsoInliers.size(); i++) {
					consensusSet.push_back(alsoInliers[i]);
				}
				Model *betterModel = new Model(consensusSet, "leastSquareFit");

				double error = betterModel->modelError(consensusSet);

				if (error < bestError) {
					bestFit = betterModel;
					bestError = error;
					//cout << "x: " << (bestFit->center).x << " y: " << (bestFit->center).y << " radius: " << bestFit->radius << endl;
					//cout << "K : " << bestFit->K << " B : " << bestFit->B << endl;
					//inliers = maybeInliers;
				}
			}
			
			iteration++;
		}
		return bestFit;
	}


	Model &modelFromData() {

	}
	
};

}

#endif
